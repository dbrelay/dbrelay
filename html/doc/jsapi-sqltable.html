<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Viaduct JavaScript Documentation : sqlTable</title>

	 <link rel="stylesheet" href="doc.css" type="text/css"/>                                                                                                                                     

	  
	</head>
	
	
	<body>
		<div id="page"> 
			<h1>sqlTable Documentation</h1>   
      <p>Abstraction of sqlDbAccess for an sql table.</p>  
      
			<h2>Example Usage</h2>    
			<pre class="codeblock">
<span class="comment">/* Create a new sqlDbAccess instance for our database connection information */</span> 
var sqlDb = sqlDbAccess({   

	<span class="comment">//Hostname on which the SQL server is running. </span>
	sql_server : '172.16.115.128', 

	<span class="comment">//Optional port number, on which the SQL server is listening. 1433 is the default.</span>
	sql_port : '',  
	<span class="comment">//Optional name of the primary database for the connection. User's default database is used, if not specified.</span>
	sql_database : 'viaducttest', 

	<span class="comment">//Username string recognised by the SQL server.</span>   
	sql_user : 'sa',                

	<span class="comment">//Optional password for the sql_user.</span>   
	sql_password : '',              

	<span class="comment">//Optional name to persist this connection under.</span>   
	connection_name : 'tabledemo',  

	<span class="comment">/*Optional number of seconds from the response to the last query before the connection will be considered idle</span> 
	<span class="comment">and marked for destroying. The default is 60. The silently enforced maximum connection lifespan is 28800 (8 hours). */</span>   
	connection_timeout : 60  
});	

<span class="comment">//Create an sqlTable for the table 'people', using the above sqlDbAccess</span>   
var myTable = sqlTable('people', sqlDb);   	

			</pre>
			
			<h2>Public Properties</h2> 
			<table class="doc-table">                 
				<thead>
					<tr>
						<th>Name</th> 
						<th>{dataType} Description</th> 
					</tr>
				</thead>
				<tbody>   
					<tr>
						<td class="doc-name">sqlDb</td>
						<td>{sqlDbAccess} sqlDbAccess instance</td>
					</tr> 

			</tbody>
			</table>
			
			
			<h2>Public Methods</h2>  
			<table class="doc-table">                 
				<thead>
					<tr>
						<th>Name</th> 
						<th>Description</th> 
					</tr>
				</thead>
				<tbody>   
					<tr>
						<td class="doc-name">sqlTable (constructor)</td>
						<td>
sqlTable constructor - creates a new sqlTable      
<pre>
sqlTable(table, sqlDb)

	@param {String} table : name of table in db  
	@param {sqlDbAccess/Object} sqlDb : sqlDbAccess object, or config used to create one.
    
 </pre>
						</td>
					</tr> 
					
					<tr>
						<td class="doc-name">queryColumns</td>
						<td>
Queries columns in this table   
<pre>
queryColumns: function(callback, scope) 
	
	@param {function} optional callback function that Will be called with the following args:
			@arg {sqlTable} this
			@arg {Object} raw json response from server      
			@arg {Array} sanitized columns data array (name, required, dataType)      
			
	@param {Ojbect} scope of callback (defaults to global)

 </pre>
						</td>
					</tr>
				 
					<tr>
						<td class="doc-name">fetchAll</td>
						<td>
Fetches all columns for all rows.  Wrapper for fetchRows   
<pre>
fetchAll: function(callback, scope)  
	
	@param {function} callback : optional callback function. Function will be called with the following params:  
			@cbparam : {sqlTable} this sqlTable
			@cbparam : {Object} raw JSON response from server
			
	@param {Object} scope : scope of callback function (defaults to global scope)
					</pre> 	</td>
					</tr> 
					       
					<tr>
						<td class="doc-name">fetchRows</td>
						<td>
Fetches columns from all rows from the table based on where conditions and server-side ordering     
<pre>
fetchRows: function(cfg, callback, scope)
	
	@param {Object} cfg : 
			@cfg {String} columns : columns to return, defaults to * . Ex:  col1,col2 
			@cfg {String} where: WHERE clause  
			@cfg {String} orderBy: server-side ORDER BY column
			@cfg {String} orderByType: optional order by type
	
	@param {function} callback : optional callback function. Function will be called with the following params:  
			@cbparam : {sqlTable} this sqlTable
			@cbparam : {Object} raw JSON response from server
			
	@param {Object} scope : scope of callback function (defaults to global scope)
						</pre> </td>
					</tr> 
					
					<tr>
						<td class="doc-name">fetchPagingRows</td>
						<td>
Fetches paged rows from the table      
<pre>
fetchPagingRows: function(cfg, callback, scope)  
		
	@param {Object} cfg : config object with the following (* required):
		@cfg {String} columns : columns to return, defaults to * . Ex:  col1,col2 
		@cfg {int} recordStart : starting 0-based index if paging (defaults to 0)
		@cfg {int} pagingSize: paging size (defaults to 20)
		@cfg {String} where: WHERE clause  
		@cfg {String} orderBy: server-side ORDER BY column (defaults to the first column) 
		@cfg {String} orderByType: asc or desc
	
	@param {function} callback : optional callback function.  Function will be called with the following params:
			@cbparam : {sqlTable} this sqlTable
			@cbparam : {Object} raw JSON response from server
			@cbparam : {Object} original cfg param
			@cbparam : {Object} a config object that is pre-configured to be used to fetch the next set of paged rows.    
			
	@param {Object} scope : scope of callback function   
					</pre>	</td>
					</tr> 
					
					<tr>
						<td class="doc-name">addRows</td>
						<td>
adds new rows to table      
<pre>
addRows : function(rows, callback, scope) 
	
	@param {Object} values : column_key/values to add   
	
	@param {function} callback : optional callback function. Function will be called with the following params:  
			@cbparam : {sqlTable} this sqlTable
			@cbparam : {Object} raw JSON response from server

	@param {Object} scope : scope of callback function (defaults to global scope)    
					 </pre>  </td>
					</tr> 
					
					<tr>
						<td class="doc-name">safeSqlString</td>
						<td>
SQL'ify a string value        
<pre>
safeSqlString : function(s)   
	
@param {string} s : string to make safe

@return {string} string with all single quotes replaced with '' AND also wrapped in single quotes (ex. 'Chicago''s')    
					 </pre>  </td>
					</tr>
					
					<tr>
						<td class="doc-name">deleteRows</td>
						<td>
Deletes row(s) from the table       
<pre>
deleteRows : function(rows, callback, scope)  
	
	@param {Array of Objects} rows : array of rows to drop, 
				each row represented by an object with key/value pairs for the WHERE clause   (i.e. [{id='2'},{key2='3'}].
					 Each clause will be AND'd together.   
					
	@param {function} callback : optional callback function. Function will be called with the following params:  
			@cbparam : {sqlTable} this sqlTable
			@cbparam : {Object} raw JSON response from server

	@param {Object} scope : scope of callback function (defaults to global scope)  
					</pre> 	</td>
					</tr>
					
					<tr>
						<td class="doc-name">updateRows</td>
						<td>
Batch update table rows.  This function assumes each row to be updated have the same where column(s), and that all WHERE clauses are AND'd together.           
<pre>
updateRows : function(set, wheres, callback, scope)  	
	
	@param {Array} set : array of objects of columnName:setValue pairs  
ex. [{name='Fred'},{name='Ted'}] or array of strings, where string is sql where clause['name LIKE \'%co%\''].  
Array can contain mixed objects & strings.
	@param {Array} wheres : array of objects to use in the where clause.
Should be same length as set param  ex: [{id='2'},{key2='3'}] 
	
	@param {function} callback : optional callback function. Function will be called with the following params:  
			@cbparam : {sqlTable} this sqlTable
			@cbparam : {Object} raw JSON response from server
			
	@param {Object} scope : scope of callback function (defaults to global scope)
					</pre> 	</td>
					</tr>
					
					 <tr>
							<td class="doc-name">queryPrimaryKeys</td>
							<td>
	Queries for this table's primary keys        
	<pre>
queryPrimaryKeys : function(callback, scope)    

	@param {function} callback : optional callback function. Function will be called with the following params:  
			@cbparam : {sqlTable} this sqlTable
			@cbparam : {Object} raw JSON response from server
			@cbparam : {Array} array of primary keys
			
	@param {Object} scope : scope of callback function (defaults to global scope)
						</pre> 	</td>
						</tr>
						
						
						<tr>
								<td class="doc-name">queryTotalRows</td>
								<td>
		Queries for the total number of records in the table that meet an optional condition        
		<pre>
queryTotalRows : function(cfg, callback, scope)

	@param cfg : configuration for this query.  Options are:
			@cfg {string} pkeys : optional.  For large tables, it is recommended that the 
table's primary key(s) be passed in as a comma delimited string
			@cfg {String/Object} where : optional. String of column/value pairs or Object of column/value pairs 
 to use in the where clause i.e. {color='red',size='large'}             
			
	@param {function} callback : optional callback function. Function will be called with the following params:  
			@cbparam : {sqlTable} this sqlTable
			@cbparam : {Object} raw JSON response from server
			@cbparam : {int} Total count of rows

	@param {Object} scope : scope of callback function (defaults to global scope)       
							</pre> 	</td>
							</tr>
			</tbody>
			</table>
		</div>
		

  </body>
</html>           




